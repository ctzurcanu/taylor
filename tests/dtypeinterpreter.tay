object "ComplexStore" {
    code {
        datacopy(0, dataoffset("Runtime"), datasize("Runtime"))
        return(0, datasize("Runtime"))
    }
    object "Runtime" {
        code {
            dtmstruct ProgStep(
                typeid: dt.byte4,
                inputIndexes: dt.u8array
                // outputHasSlotSize: dt.boolarray
            )
            dtmstruct ProgInput(
                // count: dt.u8,
                // isize: dt.u32,
                // inputHasSlotSize: dt.boolarray,
                starts: dt.u32array,
                // outputIndexes: dt.u8array,
                input: dt.byte1array
            )
            dtmstruct Type(
                sig_bytecode: dt.dTypeSignature,
                // sig_in: dt.dTypeSignature,
                // sig_out: dt.dTypeSignature,   // for named types = byte4(hash(sign_in, name))
                size: dt.u32,
                // name: dt.byte4  // char: byte1 ? u8 ascii ? bit8 ?
                steps: dt.u8
            )
            
            // mapping(sig_b -> Type) dtypes
            // mapping(sig_b -> uint8 -> ProgStep) progsteps
            // maping(sig_b -> ProgInput) proginputs
            
            
            // mapping(sig_in -> [sig_b])) in
            // mapping(sig_out -> [sig_b]) out
            // mapping(sig_b -> Type)
            // mapping(name: string -> size: u32 -> sig_b)
            
            
            // this ptr gets overwritten after each internal function call
            let _internal_output_ptr := 128
            let _calldata := 256
            let _calldata2 := add(_calldata, 4)
            let _data := add(_calldata2, 4)
            
            // input: ProgInput(_data)
            // step length: _data + ProgInput.size(_data)
            // first step: ProgStep(_data + ProgInput.size(_data) - 4)
            // second step: first_step_pos + first_step.length
            
            calldatacopy(_calldata, 0, calldatasize())
            
            let fsig := mslice(_calldata, 4)

            // // External calls only pass through execute
            // if eq(eq(inisig, 0xffffffff), false) {
            //     mslicestore(0, 0xffff, 2)
            //     revert(0, 2)
            // }
            
            switch fsig
                
            // Execute function - the only one that returns
            case 0xffffffff {
                    
                // the actual function called
                //  TODO: restrict to dtnew & dtcast
                let exec_fsig := mslice(_calldata2, 4)
                
                executeInternal(exec_fsig, _data, _internal_output_ptr)
                    
                let size := mslice(_internal_output_ptr, 4)
                return(add(_internal_output_ptr, 4), size)

            }
            
            // case dtsig"function store(bytes4 sig) view public returns(u32)" {
            case 0xfffffffe {
                // sstore(mappingInKey(Data.type.sig_in(_data)), Data.type.sig_bytecode(_data))
                // sstore(mappingOutKey(Data.type.sig_out(_data)), Data.type.sig_bytecode(_data))
                
                // input length
                let _ptr := _calldata2
                let sig_bytecode := Type.sig_bytecode(add(_ptr, 4))
                
                storeType(_ptr, sig_bytecode)
               
                _ptr := add(add(_ptr, mslice(_ptr, 4)), 4)
                storeInput(_ptr, sig_bytecode)
                
                _ptr := add(add(_ptr, mslice(_ptr, 4)), 4)
                storeProgSteps(_ptr, sig_bytecode)
            }
            
            // read from storage
            case 0xfffffffd {
                let sig := mslice(_calldata2, 4)
                let _output_ptr := _internal_output_ptr
                let length := 0
                
                let _dtype_ptr := add(_output_ptr, 4)
                getType(_dtype_ptr, sig)

                length := add(add(length, mslice(_dtype_ptr, 4)), 4)
                
                let _input_ptr := add(_dtype_ptr, length)
                getInput(_input_ptr, sig)
                length := add(add(length, mslice(_input_ptr, 4)), 4)

                let _step_ptr := add(_dtype_ptr, length)
                getProgSteps(_step_ptr, sig)
                return(_dtype_ptr, 64)
                length := add(add(length, mslice(_step_ptr, 4)), 4)
                
                return(_dtype_ptr, length)
            }
            
            default {
                mslicestore(0, 0xffff, 2)
                revert(0, 2)
            }
            
            function executeInternal(exec_fsig, _data_ptr, _output_ptr) {
                let success := executeGraph(exec_fsig, _data_ptr, _output_ptr)
                
                if eq(success, false)  {
                    executeBaseFunction(exec_fsig, _data_ptr, _output_ptr)
                }
            }
            
            // Only 1 output per graph step is supported
            function executeGraph(sig, _prev_data_ptr, _output_ptr) -> success {
                // Get dtype data from storage
                // _data_ptr is actually empty - we can copy in mem.
 
                success := false
                
                // leave space for inputs (maybe too small)
                // TODO what happens if we run multiple graphs & some data is left
                let _step_indexes_ptr := _prev_data_ptr
                let _step_inputs_ptr := add(_step_indexes_ptr, 64)
                let _starts_ptr := add(_step_inputs_ptr, 64)
                let _inputs_ptr := add(_starts_ptr, 64)
                
                let _dtype_ptr := add(_inputs_ptr, 96)
                getType(_dtype_ptr, sig)

                if eq(eq(Type.sig_bytecode(add(_dtype_ptr, 4)), sig), true) {
                    let _input_ptr := add(add(_dtype_ptr, mslice(_dtype_ptr, 4)), 4)
                    getInput(_input_ptr, sig)
                    
                    // mstore initial starts & inputs
                    ProgInput.starts.encodeTight(add(_input_ptr, 4), _starts_ptr)
                    ProgInput.input.encodeTight(add(_input_ptr, 4), _inputs_ptr)
                    
                    let _last_start_ptr := add(_starts_ptr, mul(mslice(_starts_ptr, 4), 4))

                    // loop over steps & execute them
                    // let count := Type.steps(add(_dtype_ptr, 4))
                    let _steps_ptr := add(add(_input_ptr, mslice(_input_ptr, 4)), 4)
                    getProgSteps(_steps_ptr, sig)
                    
                    for { let i := 0 } lt(i, Type.steps(add(_dtype_ptr, 4))) { i := add(i, 1) } {
                        let _step_ptr := getProgStepPointer(add(_steps_ptr, 4), i)
                        
                        // write step selection indexes
                        ProgStep.inputIndexes.encodeTight(_step_ptr, _step_indexes_ptr)
                        
                        // if eq(i, 1) { return (_step_indexes_ptr, 64) }
                        // select from indexes & starts -> write at _step_inputs_ptr
                        select(_step_indexes_ptr, _starts_ptr, _inputs_ptr, _step_inputs_ptr, i)
                        // if eq(i, 1) { return (_step_inputs_ptr, 64) }
                         
                        // output is temporarily written at mem 0
                        executeInternal(ProgStep.typeid(_step_ptr), _step_inputs_ptr, 0)
                       
                        // if eq(i, 1) { return (0, 64) }
                        // we add the output to _inputs_ptr & add its size to _starts_ptr
                        let out_size := mslice(0, 4)
                            
                        // get current input size from last start
                        let inputs_size := mslice(_last_start_ptr, 4)
                        
                        
                        // add output to inputs
                        // TODO: fixme for > 32 bytes
                        mslicestore(add(add(_inputs_ptr, 4), inputs_size), mslice(0, add(out_size, 4)), add(out_size, 4))
                        
                        // add the new start
                        _last_start_ptr := add(_last_start_ptr, 4)
                        mslicestore(_last_start_ptr, add(inputs_size, add(out_size, 4)), 4)
                        
                        // change starts length & _last_start_ptr
                        mstorehead(_starts_ptr, add(mslice(_starts_ptr, 4), 1), 4)
                        
                        _step_ptr := add(_step_ptr, 32)
                       //  return (_starts_ptr, 64)
                    }
                    
                    
                    // return (_inputs_ptr, 64)
                    // write result to _output_ptr through select
                    mslicestore(_step_indexes_ptr, 1, 4)
                    mslicestore(add(_step_indexes_ptr, 4), sub(mslice(_starts_ptr, 4), 1), 1)
                    // return (_starts_ptr, 64)
                    select(_step_indexes_ptr, _starts_ptr, _inputs_ptr, _output_ptr, 3)
                    
                    success := true
                }
            }
            
            function executeBaseFunction(sig, _data_ptr, _output_ptr) {
                switch sig
                
                // dtnew
                case 0x33333337 {
                    let _ptr := ProgInput.input.position(_data_ptr)
                    
                    let type_id := mslice(_ptr, 8)
                    let size := mslice(add(_ptr, 4), 8)
                    mslicestore(_output_ptr, size, 4)
                    dtnew(type_id, size, add(_output_ptr, 4))
                }
                
                // select
                case 0x33333336 {
                    let _ptr := ProgInput.input.position(_data_ptr)
                    // don't include input.length
                    // selectt(add(_ptr, 4), _output_ptr)
                }
                
                // dtadd
                case 0x33333333 {
                    let _ptr := ProgInput.input.position(_data_ptr)
                    let ans := dtadd(add(_ptr, 4))
                    mslicestore(_output_ptr, 4, 4)
                    mslicestore(add(_output_ptr, 4), ans, 4)
                }
                
                // dtsub
                case 0x33333334 {
                    let _ptr := ProgInput.input.position(_data_ptr)
                    let ans := dtsub(add(_ptr, 4))
                    mslicestore(_output_ptr, 4, 4)
                    mslicestore(add(_output_ptr, 4), ans, 4)
                }
                
                // contig
                case 0x33333335 {
                    // let _ptr := ProgInput.input.position(_data_ptr)
                    // contig(_ptr, _output_ptr)
                    // remove additional length
                    contig(add(_data_ptr, 4), _output_ptr)
                }
    
                // byte1
                case 0x33333338 {
                    // let _ptr := ProgInput.input.position(_data_ptr)
                    let ans := byte1()
                    mslicestore(_output_ptr, 1, 4)
                    mslicestore(add(_output_ptr, 4), ans, 1)
                }
                
                 default {
                    mslicestore(0, 0xfffe, 2)
                    revert(0, 2)
                }
            }
            
            function mslicestore(_ptr, val, length) {
                let slot := 32
                mstore(_ptr, shl(mul(sub(slot, length), 8), val))
            }
            
            function sslicestore(storageKey, val, length) {
                let slot := 32
                sstore(storageKey, shl(mul(sub(slot, length), 8), val))
            }
            
            // Use carefully - replaces head bytes in a byte32 chunk
            function mstorehead(_ptr, value, length) {
                let slot := 32
                let temp := mload(_ptr)
                mslicestore(_ptr, value, length)
                mslicestore(add(_ptr, length), temp, safeSub(slot, length))
            }
            
            function mmultistore(_ptr_target, _ptr_source, sizeBytes) {
                let slot := 32
                let size := div(sizeBytes, slot)
 
                for { let i := 0 } lt(i, size)  { i := add(i, 1) } {
                    mstore(add(_ptr_target, mul(i, slot)), mload(add(_ptr_source, mul(i, slot))))
                }
                
                let current_length :=  mul(size, slot)
                let remaining := sub(sizeBytes, current_length)
                if gt(remaining, 0) {
                    mslicestore(
                        add(_ptr_target, current_length),
                        mslice(add(_ptr_source, current_length), remaining),
                        remaining
                    )
                }
            }
            
            function min(a, b) -> c {
                switch lt(a, b)
                case 1 { c := a }
                case 0 { c := b }
            }
            
            function max(a, b) -> c {
                switch gt(a, b)
                case 1 { c := a }
                case 0 { c := b }
            }
            
            function byte1() -> ans {
                ans := 0x11
            }
            
             function dtadd(pointer) -> ans {
                let a := mslice(pointer, 4)
                let b := mslice(add(pointer, 4), 4)
                ans := add(a, b)
            }
            
            function dtsub(pointer) -> ans {
                let a := mslice(pointer, 4)
                let b := mslice(add(pointer, 4), 4)
                ans := sub(a, b)
            }
            
            function contig(pointer, output_ptr) {
                let slot := 32
                let a := mslice(pointer, 4)
                let b_length := mslice(add(pointer, 4), 4)
                let b_pointer := add(pointer, 8)
                mslicestore(output_ptr, mul(a, b_length), 4)
                let ans_ptr := add(output_ptr, 4)

                for { let i := 0 } lt(i, a) { i := add(i, 1) } {
                    mstore(add(ans_ptr, mul(b_length, i)), shl(mul(sub(slot, b_length), 8), mslice(b_pointer, b_length)))
                }
            }
            
            function dtnew(type_id, size, _ptr) {
                //  size - if types have same id
                
                // following is defined by a type_id's progsteps
                // dtnew -> gets dtype data -> executeInternal(dtype.steps)
                let pt := 0
                
                mslicestore(pt, size, 4)
                mslicestore(add(pt, 4), 1, 4)
                mslicestore(add(pt, 8), 0x00, 1)
                contig(pt, _ptr)
            }
            
            function cast(type_id1, value_ptr, type_id2, answ_ptr) {
                
            }
            
            // function selectt(pointer, _output_ptr) {
            //     let select_pointer := pointer
            //     let select_length := mslice(select_pointer, 4)
                
            //     let starts_pointer := add(select_pointer, mul(select_length, 4))
            //     let starts_length := mslice(starts_pointer, 4)
                
            //     let b_pointer := add(starts_pointer, mul(starts_length, 4))
                
            //     select(select_pointer, starts_pointer, b_pointer, _output_ptr)
            // }
            
            // TODO: rewrite this more efficient
            function select(select_ptr, starts_ptr, b_ptr, _output_ptr, step) {
                let select_length := mslice(select_ptr, 4)
                let select_pointer := add(select_ptr, 4)
                
                let starts_length := mslice(starts_ptr, 4)
                let starts_pointer := add(starts_ptr, 4)
                
                let content_pointer := add(_output_ptr, 4)
                let b_pointer := add(b_ptr, 4)
                
                
                for { let i := 0 } lt(i, select_length) { i := add(i, 1) } {
                    let index := mslice(add(select_pointer, mul(i, 1)), 1) // byte1 index value
                    
                    let start := 0
                    if gt(index, 0) {
                        start := mslice(add(starts_pointer, mul(sub(index, 1), 4)), 4)
                    }
                    let length := sub(mslice(add(starts_pointer, mul(index, 4)), 4), start)
                    
                    mslicestore(content_pointer,  mslice(add(b_pointer, start), length), length)
                    content_pointer := add(content_pointer, length)
                }

                mstorehead(_output_ptr, sub(content_pointer, add(_output_ptr, 4)), 4)
            }

            function dtif(condition, type_id1, type_id2, arg_ptr, res_ptr) {
                switch condition
                case 0x01 {
                    dtapply(type_id1, arg_ptr, res_ptr)
                }
                case 0x02 {
                    dtapply(type_id2, arg_ptr, res_ptr)
                }
            }
            
            function dtapply(type_id, arg_ptr, res_ptr) {
                // fsig := type_id
            }
            
                
                // case 0x22222222 {
                //     mstore(_data, shl(mul(sub(32, 4), 8), 0x00000011))  // sig_bytecode
                //     mstore(add(_data, 4), shl(mul(sub(32, 4), 8), 0x00000022))  // sig_in
                //     mstore(add(_data, 8), shl(mul(sub(32, 4), 8), 0x00000033))  // sig_out
                //     mstore(add(_data, 12), shl(mul(sub(32, 4), 8), 0x00000008))  // ssize
                    
                //     mstore(add(_data, 16), shl(mul(sub(32, 4), 8), 0x00000002)) // steps length
                    
                //     mstore(add(_data, 20), shl(mul(sub(32, 4), 8), 0xcccccccc)) // typeid
                //     mstore(add(_data, 24), shl(mul(sub(32, 5), 8), 0x0000000105)) // inputIndexes
                //     mstore(add(_data, 29), shl(mul(sub(32, 5), 8), 0x0000000101)) // outputHasSlotSize
                    
                //     mstore(add(_data, 34), shl(mul(sub(32, 4), 8), 0xdddddddd)) // typeid
                //     mstore(add(_data, 38), shl(mul(sub(32, 5), 8), 0x0000000106)) // inputIndexes
                //     mstore(add(_data, 43), shl(mul(sub(32, 5), 8), 0x0000000100)) // outputHasSlotSize
                    
                //     fsig := 0x2edc3142
                // }
                
                // case dtsig"function getSigBByIn(byte4 sig) view public returns(u32)" {
                //     let key := mappingInKey(Data.type.sig_in(_data))
                //     mstore(0, sload(key))
                //     return (0, 32)
                // }
                
                // case dtsig"function getSigBByOut(byte4 sig) view public returns(u32)" {
                //     let key := mappingOutKey(Data.type.sig_out(_data))
                //     mstore(0, sload(key))
                //     return (0, 32)
                // }
                
            
            function storeType(_pointer, mapKey) {
                storeData(_pointer, mappingTypeKey(mapKey))
            }
            
            function storeInput(_pointer, mapKey) {
                storeData(_pointer, mappingProgInputKey(mapKey))
            }
            
            function storeProgSteps(_pointer, mapKey) {
                storeData(_pointer, mappingProgStepsKey(mapKey))
            }
            
            function getType(_pointer, mapKey) {
                getStoredData(_pointer, mappingTypeKey(mapKey))
            }
            
            function getInput(_pointer, mapKey) {
                getStoredData(_pointer, mappingProgInputKey(mapKey))
            }
            
            function getProgSteps(_pointer, mapKey) {
                getStoredData(_pointer, mappingProgStepsKey(mapKey))
            }
            
            // does not contain the steps size
            function getProgStepPointer(_pointer, index) -> _new_ptr {
                _new_ptr := _pointer
                for { let i := 0 } lt(i, index) { i := add(i, 1) } {
                    let input_indexes_length := mslice(add(_new_ptr, 4), 4)
                    _new_ptr := add(add(_new_ptr, 8), mul(input_indexes_length, 1))
                }
            }
            
            // function getProgStep(_pointer, key1, key2) {
            //     getStoredData(_pointer, mappingProgStepKey(key1, key2))
            // }
            
            function storeData(_pointer, storageKey) {
                let slot := 32
                let sizeBytes := add(mslice(_pointer, 4), 4)
                let size := div(sizeBytes, slot)

                for { let i := 0 } lt(i, size)  { i := add(i, 1) } {
                    sstore(add(storageKey, i), mload(add(_pointer, mul(i, slot))))
                }
                
                let current_length :=  mul(size, slot)
                let remaining := sub(sizeBytes, current_length)
                if gt(remaining, 0) {
                    sslicestore(add(storageKey, size), mslice(add(_pointer, current_length), remaining), remaining)
                }
            }
            
            function getStoredData(_pointer, storageKey) {
                let slot := 32
                
                // read first storage slot, for the length
                mstore(_pointer, sload(storageKey))

                let sizeBytes := mslice(_pointer, 4)
                let loadedData := sub(slot, 4)
                if gt(sizeBytes, loadedData) {
                    sizeBytes := sub(sizeBytes, loadedData)
                    let size := div(sizeBytes, slot)
                    _pointer :=  add(_pointer, slot)

                    for { let i := 0 } lt(i, size)  { i := add(i, 1) } {
                        mstore(add(_pointer, mul(i, slot)), sload(add(storageKey, i)))
                    }
                    
                    let current_length :=  mul(size, slot)
                    let remaining := sub(sizeBytes, current_length)
                    if gt(remaining, 0) {
                        mslicestore(add(_pointer, current_length), sload(add(storageKey, size)), remaining)
                    }
                }
            }
            
            // function mappingInKey(key) -> storageKey {
            //     storageKey := mappingStorageKey(0, key)
            // }
            
            // function mappingOutKey(key) -> storageKey {
            //     storageKey := mappingStorageKey(1, key)
            // }
            
            function mappingTypeKey(key) -> storageKey {
                storageKey := mappingStorageKey(0, key)
            }
            
            function mappingProgInputKey(key) -> storageKey {
                storageKey := mappingStorageKey(1, key)
            }
            
            function mappingProgStepsKey(key) -> storageKey {
                storageKey := mappingStorageKey(2, key)
            }
            
            // function mappingProgStepKey(sig_b, step_count) -> storageKey {
            //     storageKey := mappingStorageKey2(2, sig_b, step_count)
            // }
            
            // function mappingNamedKey(key1, key2) -> storageKey {
            //     storageKey := mappingStorageKey2(3, key1, key2)
            // }
            
             // mapping(bytes32(max) => *)
            function mappingStorageKey(storageIndex, key) -> storageKey {
                mstore(0, key, storageIndex)
                storageKey := keccak256(0, 64)
            }
    
            // mapping(bytes32(max) => mapping(bytes32(max) => *)
            function mappingStorageKey2(storageIndex, key1, key2) -> storageKey {
                mstore(0, key1, storageIndex, key2)
                mstore(96, keccak256(0, 64))
                storageKey := keccak256(64, 64)
            }
        }
    }
}

