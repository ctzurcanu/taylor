object "ComplexStore" {
    code {
        datacopy(0, dataoffset("Runtime"), datasize("Runtime"))
        return(0, datasize("Runtime"))
    }
    object "Runtime" {
        code {
            dtmstruct ProgStep(
                typeid: dt.byte4,
                inputIndexes: dt.u8array
            )
            // native input (abstract type); external input (e.g. sizes)
            dtmstruct ProgInput(
                starts: dt.u32array,
                input: dt.byte1array
            )
            dtmstruct Type(
                sig_bytecode: dt.dTypeSignature,
                // sig_in: dt.dTypeSignature,
                // sig_out: dt.dTypeSignature,   // for named types = byte4(hash(sign_in, name))
                // name: dt.byte4  // char: byte1 ? u8 ascii ? bit8 ?
                steps: dt.u8
            )



            // mapping(sig_b -> Type) dtypes
            // maping(sig_b -> ProgInput) proginputs
            // mapping(sig_b -> )


            // mapping(sig_in -> [sig_b])) in
            // mapping(sig_out -> [sig_b]) out
            // mapping(sig_b -> Type)
            // mapping(name: string -> size: u32 -> sig_b)


            // this ptr gets overwritten after each internal function call
            let _internal_output_ptr := 128
            let _calldata := 256
            let _calldata2 := add(_calldata, 4)
            let _data := add(_calldata2, 4)
            let _internal_data := add(_data, 1024)

            calldatacopy(_calldata, 0, calldatasize())

            let fsig := mslice(_calldata, 4)


            switch fsig

            case 0xffffffff {
                let exec_fsig := mslice(_calldata2, 4)

                // !!! always 96 diff between them
                // let starts_ptr := _data
                // let inputs_ptr := add(starts_ptr, 96)
                // dtype data is sub(starts_ptr, 512)

                addGraphProgInput(_data, _internal_data, add(_internal_data, 96), 0)
                executeInternal(exec_fsig, _internal_data, _internal_output_ptr)

                let input_size := getlengthFromStarts(_internal_output_ptr)
                let starts_size := getStartsLength(_internal_output_ptr)

                return (_internal_output_ptr, add(starts_size, input_size))
            }

            // case dtsig"function store(bytes4 sig) view public returns(u32)" {
            case 0xfffffffe {
                // sstore(mappingInKey(Data.type.sig_in(_data)), Data.type.sig_bytecode(_data))
                // sstore(mappingOutKey(Data.type.sig_out(_data)), Data.type.sig_bytecode(_data))

                // input length
                let _ptr := _calldata2
                let sig_bytecode := Type.sig_bytecode(add(_ptr, 4))

                storeType(_ptr, sig_bytecode)

                _ptr := add(add(_ptr, mslice(_ptr, 4)), 4)
                storeInput(_ptr, sig_bytecode)

                _ptr := add(add(_ptr, mslice(_ptr, 4)), 4)
                storeProgSteps(_ptr, sig_bytecode)
            }

            // read from storage
            case 0xfffffffd {
                let sig := mslice(_calldata2, 4)
                let _output_ptr := _internal_output_ptr
                let length := 0

                let _dtype_ptr := add(_output_ptr, 4)
                // getType(_dtype_ptr, sig)

                length := add(add(length, mslice(_dtype_ptr, 4)), 4)

                let _input_ptr := add(_dtype_ptr, length)
                getInput(_input_ptr, sig)
                length := add(add(length, mslice(_input_ptr, 4)), 4)

                let _step_ptr := add(_dtype_ptr, length)
                getProgSteps(_step_ptr, sig)

                length := add(add(length, mslice(_step_ptr, 4)), 4)

                return(_dtype_ptr, length)
            }

            default {
                mslicestore(0, 0xffff, 2)
                revert(0, 2)
            }

            function executeInternal(exec_fsig, _data_ptr, _output_ptr) {
                let success := executeBaseFunction(exec_fsig, _data_ptr, _output_ptr)

                if eq(success, false)  {
                    executeGraph(exec_fsig, _data_ptr, _output_ptr)
                }
            }

            function executeGraph(sig, _data_ptr, _output_ptr) {
                // There might be external inputs at _starts_ptr & _inputs_ptr
                // we get the length & write ProgInput.input after it
                let _starts_ptr1 := _data_ptr
                let _inputs_ptr := add(_starts_ptr1, 96)
                let _dtype_ptr := sub(_data_ptr, 512)

                // if eq(sig, 44444444) { return (_data_ptr, 128) }

                // Get dtype data from storage
                getType(_dtype_ptr, sig)
                dtrequire(
                    eq(Type.sig_bytecode(add(_dtype_ptr, 4)), sig),
                    0xee
                )

                // Get dtype input data from storage
                let _input_ptr := add(add(_dtype_ptr, mslice(_dtype_ptr, 4)), 4)
                getInput(_input_ptr, sig)

                // mstore add graph starts & inputs to possibly already existing starts & inputs
                addGraphProgInput(add(_input_ptr, 4), _starts_ptr1, _inputs_ptr, 1)

                let _steps_ptr := add(add(_input_ptr, mslice(_input_ptr, 4)), 4)
                getProgSteps(_steps_ptr, sig)

                executeGraphSteps(
                    _steps_ptr,
                    _starts_ptr1,
                    _inputs_ptr,
                    Type.steps(add(_dtype_ptr, 4)),
                    _output_ptr
                )
            }

            function executeGraphSteps(_steps_ptr, _starts_ptr_, _inputs_ptr, step_count, _output_ptr) {
                let _step_indexes_ptr := add(_inputs_ptr, 1024)
                let _step_starts := add(_step_indexes_ptr, 32)
                let _step_inputs_ptr := add(_step_starts, 96)

                // loop over steps & execute them
                for { let i := 0 } lt(i, step_count) { i := add(i, 1) } {
                    let _step_ptr := getProgStepPointer(add(_steps_ptr, 4), i)

                    executeGraphStep(
                        _step_ptr, _step_indexes_ptr,
                        _step_starts, _step_inputs_ptr,
                        _starts_ptr_, _inputs_ptr, i
                    )
                }

                // write result to _output_ptr through select
                // write indexes length
                mslicestore(_step_indexes_ptr, 1, 4)
                // only 1 output now - the last one
                mslicestore(add(_step_indexes_ptr, 4), sub(mslice(_starts_ptr_, 4), 1), 1)

                select(
                    _step_indexes_ptr,
                    _starts_ptr_,
                    _inputs_ptr,
                    _step_starts,
                    _step_inputs_ptr
                )

                identity(_step_starts, _step_inputs_ptr, _output_ptr)
            }

            function executeGraphStep(
                _step_ptr, _step_indexes_ptr,
                _step_starts, _step_inputs_ptr,
                _starts_ptr2, _inputs_ptr, i
            ) {
                    // write step selection indexes
                    ProgStep.inputIndexes.encodeTight(_step_ptr, _step_indexes_ptr)

                    // select from indexes & starts -> write at _step_inputs_ptr
                    select(_step_indexes_ptr, _starts_ptr2, _inputs_ptr, _step_starts, _step_inputs_ptr)

                    // if eq(i, 1) { return (_step_starts, 128) }
                    // if eq(ProgStep.typeid(_step_ptr), 0x44444444) { return (_inputs_ptr, 128) }

                    // output is temporarily written at mem 0
                    // result also has a tuple encoding, based on structs
                    executeInternal(ProgStep.typeid(_step_ptr), _step_starts, 0)

                    // we add the output to _inputs_ptr & add its size to _starts_ptr
                    addGraphProgInput(0, _starts_ptr2, _inputs_ptr, 1)
            }

            function addGraphProgInput(source_starts, _starts_ptr, _inputs_ptr, additive) {
                //  these starts already account for what data is expected from sources
                // external to this graph - they have correct values
                let start_size := mul(getSize(source_starts), 4)
                let input_size := getlengthFromStarts(source_starts)

                let last_start_index := getlastStartsIndex(_starts_ptr)
                let last_input_index := add(_inputs_ptr, getlengthFromStarts(_starts_ptr))
                let source_inputs := add(getlastStartsIndex(source_starts), 4)
                let source_count := getSize(source_starts)

                // change number of starts
                if eq(last_start_index, _starts_ptr) {
                    mslicestore(_starts_ptr, 0xee000000, 4)
                }

                addToSize(_starts_ptr, source_count)

                // store inputs unchanged
                mmultistore(last_input_index, source_inputs, input_size)

                switch additive
                case 0 {
                    // store starts unchanged
                    mmultistore(add(last_start_index, 4), add(source_starts, 4), start_size)
                }
                case 1 {
                    // loop through starts, to add them one by one
                    let last_end := mslice(last_start_index, 4)
                    for { let i := 0 } lt(i, source_count) { i := add(i, 1) } {
                        last_start_index := add(last_start_index, 4)
                        last_end := add(
                            last_end,
                            mslice(add(add(source_starts, 4), mul(i, 4)), 4)
                        )
                        mslicestore(last_start_index, last_end, 4)
                    }
                }
            }

            function executeBaseFunction(sig, starts_ptr, _output_ptr) -> success {
                let _input_ptr := add(starts_ptr, 96)
                success := true

                switch sig

                // // is_not_none
                // case 0x33333339 {
                //     let index := mslice(_input_ptr, 4)
                //     let not_none := is_not_none(index, starts_ptr)
                //     // starts
                //     mslicestore(_output_ptr, 1, 4)
                //     mslicestore(_output_ptr, 1, 4)
                //     mslicestore(_output_ptr, not_none, 4)
                // }

                // byte1
                case 0x33333338 {
                    let ans := byte1()
                    // starts
                    mslicestore(_output_ptr, 0xee000001, 4)
                    mslicestore(add(_output_ptr, 4), 5, 4)
                    // inputs
                    mslicestore(add(_output_ptr, 8), 0x22000001, 4)
                    mslicestore(add(_output_ptr, 12), ans, 1)
                }

                // function dtnew(abstract_type_id, size, _primordial_matter_ptr)
                case 0x33333337 {
                    // type id, size
                    // e.g. 220000041100000011000003000004
                    let type_id := mslice(add(_input_ptr, 4), 4)
                    let size := mslice(add(_input_ptr, 12), 3)

                    switch size
                    // if type is stored with a size, we don't need external inputs
                    case 0 {
                        mstore(_input_ptr, 0x00000000)
                        mstore(starts_ptr, 0x0000000000000000000000000000000000000000000000000000000000000000)
                    }
                    default {
                        mslicestore(_input_ptr, 0x11000003, 4)
                        mslicestore(add(_input_ptr, 4), size, 3)

                        mslicestore(starts_ptr, 0xee00000100000007, 8)
                    }

                    executeInternal(type_id, starts_ptr, _output_ptr)
                }

                 // contig (count, b_length, b_pointer, output_ptr)
                case 0x33333335 {
                    //  count, bytes
                    // eg. starts: 0xee000002000000070000000c
                    // eg. inputs: 110000030000042200000111

                    // type checking count/size to be u28
                    dtrequire(eq(mslice(_input_ptr, 4), 0x11000003), 0xef)
                    let count := mslice(add(_input_ptr, 4), 3)

                    // byte type id
                    let type_header := 0x22

                    let bytes_length := mslice(add(_input_ptr, 8), 3)

                    // if eq(bytes_length, 32) { return(starts_ptr, 172) }

                    let size := mul(count, bytes_length)
                    // starts
                    mslicestore(_output_ptr, 0xee, 1)
                    mslicestore(add(_output_ptr, 1), 1, 3)
                    mslicestore(add(_output_ptr, 4), add(4, size), 4)
                    mslicestore(add(_output_ptr, 8), type_header, 1)
                    mslicestore(add(_output_ptr, 9), size, 3)

                    contig(count, bytes_length, add(_input_ptr, 11), add(_output_ptr, 12))
                }

                // identity function
                case 0x33333334 {
                    identity(starts_ptr, _input_ptr, _output_ptr)
                }

                // prod
                case 0x33333333 {
                    // starts
                    mslicestore(_output_ptr, 1, 4)
                    mslicestore(add(_output_ptr, 4), 1, 4)
                    // inputs
                    mslicestore(add(_output_ptr, 8), 1, 4)
                    mslicestore(add(_output_ptr, 12), dtprod(_input_ptr), 4)
                }

                // map (_array_ptr, bytes_length, fsig, _output_ptr)
                // case 0x33333332 {
                //     // inputs: (len), sig, array ; starts: (len), 4, x
                //     let sig := mslice(inputs_ptr, 4)
                //     // subtract array length
                //     let bytes_length := sub(mslice(add(starts_ptr, 8), 4), mslice(add(starts_ptr, 4), 4))
                //     map(add(inputs_ptr, 4), bytes_length, sig, _output_ptr)
                // }

                // reduce : ffsig, array, initial value
                case 0x33333331 {
                    // first elem is inputs length ??
                    let ffsig := mslice(add(_input_ptr, 4), 4)
                    // starts[1] - starts[0]
                    let bytes_length := sub(mslice(add(starts_ptr, 8), 4), mslice(add(starts_ptr, 4), 4))
                    let initial_value_ptr := add(add(_input_ptr, bytes_length), 8)
                    // starts[2] - starts[1]
                    let initial_value_length := sub(mslice(add(starts_ptr, 12), 4), mslice(add(starts_ptr, 8), 4))

                    reduce(ffsig, add(_input_ptr, 8), bytes_length, initial_value_ptr, initial_value_length, _output_ptr)
                }

                // concat - concatenates untyped values
                // used for building typed values from components -> concat does not need to have a special
                // return type - it just wraps the value in a tuple
                case 0x33333330 {
                    let count := getSize(starts_ptr)

                    mslicestore(_output_ptr, 0xee000001, 4)

                    let source_ptr := _input_ptr
                    let target_ptr := add(_output_ptr, 8)
                    let length := 0

                    for { let i := 0 } lt(i, count) { i := add(i, 1) } {
                        let length_bytes := getTypeLength(source_ptr)
                        let value_ptr := getValuesPointer(source_ptr)
                        mmultistore(target_ptr, value_ptr, length_bytes)

                        length := add(length, length_bytes)
                        source_ptr := add(add(source_ptr, length_bytes), 4)
                        target_ptr := add(target_ptr, length_bytes)
                    }
                    mstorehead(add(_output_ptr, 4), length, 4)
                }

                // getTypeSignature
                case 0x33333329 {
                    let type_id := mslice(_input_ptr, 4)

                    // starts
                    mslicestore(_output_ptr, 0xee0000010000000822000004, 12)
                    mslicestore(add(_output_ptr, 12), type_id, 4)
                }

                // // times function
                // case 0x33333333 {
                //     let times := mslice(_input_ptr, 4)
                //     let sig_function := mslice(add(_input_ptr, 4), 4)
                //     let type_id := mslice(add(_input_ptr, 8), 4)

                //     times(times, sig_function, type_id)
                // }

                // function times(starts_ptr, inputs_ptr, _output_ptr) {
                //     let times := mslice(_input_ptr, 4)
                //     let sig_function := mslice(add(_input_ptr, 4), 4)
                //     let type_id := mslice(add(_input_ptr, 8), 4)



                //     dtif(
                //         iszero(times),
                //         executeInternal(type_id, starts_ptr, _output_ptr),

                //         // executeInternal(0x33333333, starts_ptr, _output_ptr) // sub times & replace

                //         times(sub(times, 1), sig_function, executeInternal(sig_function, starts_ptr, _output_ptr))
                //     )
                // }

                // // Times(times:u32, T1, T2) = If( Eq(times, 0), T2, Times( Sub(times, 1), T1, T1( T2)))
                // function times(times, sig_function, type_id) {
                //     dtif(
                //         iszero(times),
                //         executeInternal(type_id, starts_ptr, _output_ptr),

                //         // executeInternal(0x33333333, starts_ptr, _output_ptr) // sub times & replace

                //         times(sub(times, 1), sig_function, executeInternal(sig_function, starts_ptr, _output_ptr))
                //     )
                // }

                // function apply()

                // // select
                // case 0x33333336 {
                //     let _ptr := ProgInput.input.position(_data_ptr)
                //     // don't include input.length
                //     // selectt(add(_ptr, 4), _output_ptr)
                // }

                // // dtadd
                // case 0x33333333 {
                //     let _ptr := ProgInput.input.position(_data_ptr)
                //     let ans := dtadd(add(_ptr, 4))
                //     mslicestore(_output_ptr, 4, 4)
                //     mslicestore(add(_output_ptr, 4), ans, 4)
                // }

                // // dtsub
                // case 0x33333334 {
                //     let _ptr := ProgInput.input.position(_data_ptr)
                //     let ans := dtsub(add(_ptr, 4))
                //     mslicestore(_output_ptr, 4, 4)
                //     mslicestore(add(_output_ptr, 4), ans, 4)
                // }

                 default {
                    // mslicestore(0, 0xfffe, 2)
                    // revert(0, 2)
                    success := false
                }
            }

            function dtrequire(cond, error_bytes) {
                if lt(cond, 1) {
                    mstore(0, error_bytes)
                    revert(0, 2)
                }
            }

            function mslicestore(_ptr, val, length) {
                let slot := 32
                mstore(_ptr, shl(mul(sub(slot, length), 8), val))
            }

            function sslicestore(storageKey, val, length) {
                let slot := 32
                sstore(storageKey, shl(mul(sub(slot, length), 8), val))
            }

            // Use carefully - replaces head bytes4 in a byte32 chunk
            function mstorehead(_ptr, value, length) {
                let slot := 32
                let temp := add(
                    mslice(add(_ptr, 4), sub(slot, 4)),
                    shl(mul(sub(slot, length), 8), value)
                )
                mstore(_ptr, temp)
            }

            //  0x11000004...
            function mstoremiddle(_ptr, start, value, length) {
                let slot := 32
                let end := add(start, length)
                let valoffset := sub(sub(slot, length), start)
                let temp := add(
                    add(
                        mslice(add(_ptr, end), sub(slot, end)),
                        shl(mul(valoffset, 8), value)
                    ),
                    shl(mul(sub(slot, start), 8), mslice(_ptr, 1))
                )
                mstore(_ptr, temp)
            }

            function mmultistore(_ptr_target, _ptr_source, sizeBytes) {
                let slot := 32
                let size := div(sizeBytes, slot)

                for { let i := 0 } lt(i, size)  { i := add(i, 1) } {
                    mstore(add(_ptr_target, mul(i, slot)), mload(add(_ptr_source, mul(i, slot))))
                }

                let current_length :=  mul(size, slot)
                let remaining := sub(sizeBytes, current_length)
                if gt(remaining, 0) {
                    mslicestore(
                        add(_ptr_target, current_length),
                        mslice(add(_ptr_source, current_length), remaining),
                        remaining
                    )
                }
            }

            function min(a, b) -> c {
                switch lt(a, b)
                case 1 { c := a }
                case 0 { c := b }
            }

            function max(a, b) -> c {
                switch gt(a, b)
                case 1 { c := a }
                case 0 { c := b }
            }

            function is_not_none(index, starts_ptr) -> ans {
                // index - end
                let start, end := boundsFromStarts(index, starts_ptr)
                ans := eq(iszero(sub(end, start)), false)
            }

            function byte1() -> ans {
                ans := 0x11
            }

             function dtadd(pointer) -> ans {
                let a := mslice(pointer, 4)
                let b := mslice(add(pointer, 4), 4)
                ans := add(a, b)
            }

            function dtsub(pointer) -> ans {
                let a := mslice(pointer, 4)
                let b := mslice(add(pointer, 4), 4)
                ans := sub(a, b)
            }

            function dtprod(pointer) -> ans {
                let a := mslice(pointer, 4)
                let b := mslice(add(pointer, 4), 4)
                ans := mul(a, b)
            }

            function identity(starts_ptr, _input_ptr, _output_ptr) {
                let input_size := getlengthFromStarts(starts_ptr)
                let starts_size := getStartsLength(starts_ptr)

                mmultistore(_output_ptr, starts_ptr, starts_size)
                mmultistore(add(_output_ptr, starts_size), _input_ptr, input_size)
            }

            function contig(count, b_length, b_pointer, output_ptr) {
                let slot := 32
                for { let i := 0 } lt(i, count) { i := add(i, 1) } {
                    let ans_ptr := add(output_ptr, mul(b_length, i))
                    mmultistore(ans_ptr, b_pointer, b_length)
                }
            }

            function dtif(condition, t_output, f_output) -> ans {
                switch condition
                case 1 {
                    ans := t_output
                }
                case 0 {
                    ans := f_output
                }
            }

            function dtapply(type_id, arg_ptr, res_ptr) {
                // fsig := type_id
            }

            function cast(type_id1, value_ptr, type_id2, answ_ptr) {

            }

            // function selectt(pointer, _output_ptr) {
            //     let select_pointer := pointer
            //     let select_length := mslice(select_pointer, 4)

            //     let starts_pointer := add(select_pointer, mul(select_length, 4))
            //     let starts_length := mslice(starts_pointer, 4)

            //     let b_pointer := add(starts_pointer, mul(starts_length, 4))

            //     select(select_pointer, starts_pointer, b_pointer, _output_ptr)
            // }

            // TODO: rewrite this more efficient
            function select(select_ptr, starts_ptr, inputs_ptr, _output_starts, _output_ptr) {
                let select_length := mslice(select_ptr, 4)
                let select_pointer := add(select_ptr, 4)
                let starts_pointer := add(starts_ptr, 4)
                let output_pointer := _output_ptr
                // if eq(mslice(select_ptr, 4), 2) { return (inputs_ptr, 128) }
                selectInner(select_pointer, starts_pointer, inputs_ptr, _output_starts, output_pointer, select_length)
            }

            function selectInner(select_ptr, starts_ptr, inputs_ptr, _output_starts, _output_ptr, select_length) {
                let sum_length := 0

                // add tuple type with size 0xee<size byte4>
                mslicestore(_output_starts, 0xee, 1)
                mslicestore(add(_output_starts, 1), select_length, 3)

                // if eq(select_length, 2) { return (inputs_ptr, 128) }

                for { let i := 0 } lt(i, select_length) { i := add(i, 1) } {
                    let index := mslice(add(select_ptr, mul(i, 1)), 1)
                    let start, length := selectOne(select_ptr, index, starts_ptr, inputs_ptr)

                    // add new end
                    mslicestore(add(add(_output_starts, 4), mul(i, 4)), add(sum_length, length), 4)

                    // add new input
                    mmultistore(add(_output_ptr, sum_length), add(inputs_ptr, start), length)

                    sum_length := add(sum_length, length)
                }
                // if eq(select_length, 2) { return (_output_starts, 128) }
            }

            function selectOne(select_ptr, index, _starts_ptr, inputs_ptr) -> start, length {
                // enforced rule for making the selector dynamic, based on ProgInput values
                // for implementing Union type
                if gt(index, 128) {
                    index := sub(255, index)
                    let st, len := selectOne(select_ptr, index, _starts_ptr, inputs_ptr)
                    index := mslice(add(inputs_ptr, st), len)
                }
                let end := 0
                start, end := boundsFromStarts(index, _starts_ptr)
                length := sub(end, start)
            }

            function reduce(funcsig, array_ptr, bytes_length, accumulator_ptr, accumulator_length, _output_ptr) {
                let len := mslice(array_ptr, 4)
                let itemlength := div(sub(bytes_length, 4), len)
                let array_values := add(array_ptr, 4)

                let new_starts_ptr := add(add(array_values, bytes_length), accumulator_length)
                let new_inputs_ptr := add(new_starts_ptr, 96)
                let accum_ptr := accumulator_ptr
                let accum_length := accumulator_length

                // Number of starts always remains 2
                mslicestore(new_starts_ptr, 2, 4)

                for { let i:= 0 } lt(i, len) { i := add(i, 1) } {
                    // starts_ptr & inputs_ptr contain initial/prev value + current item

                    let current_value_ptr := reduceUtil(accum_ptr, accum_length, itemlength, new_starts_ptr, new_inputs_ptr)

                    // add current value
                    mmultistore(current_value_ptr, add(array_values, mul(i, itemlength)), itemlength)
                    mstore(_output_ptr, 0)

                    executeInternal(funcsig, new_starts_ptr, _output_ptr)

                    accum_length := mslice(_output_ptr, 4)
                    accum_ptr := add(_output_ptr, 4)
                }

                // mslicestore(_output_ptr, add(new_starts_ptr, 4), 4)
                // mmultistore(add(_output_ptr, 4), accum_ptr, mslice(add(new_starts_ptr, 4), 4))
            }

            // sets: updates both starts, inputs length, accum value in inputs
            function reduceUtil(accum_ptr, accum_length, itemlength, new_starts_ptr, new_inputs_ptr) -> current_value_ptr {
                // let accum_new_ptr := add(new_inputs_ptr, 4)
                let accum_new_ptr := new_inputs_ptr

                mslicestore(add(new_starts_ptr, 4), accum_length, 4)
                mslicestore(add(new_starts_ptr, 8), add(accum_length, itemlength), 4)

                // mslicestore(new_inputs_ptr, add(accum_length, itemlength), 4)
                mmultistore(accum_new_ptr, accum_ptr, accum_length)
                current_value_ptr := add(accum_new_ptr, accum_length)
            }

            // // another array is written at _output_ptr
            // function map(_array_ptr, bytes_length, fsig, _output_ptr) {
            //     let len := mslice(_array_ptr, 4)
            //     let itemlength := div(bytes_length, len)
            //     let _values_ptr := add(_array_ptr, 4)

            //     for { let i:= 0 } lt(i, len) { i := add(i, 1) } {
            //         mslicestore(starts_ptr, 1, 4)
            //         mslicestore(inputs_ptr, mslice(add(_values_ptr, mul(itemlength, i)), itemlength))
            //         executeInternal(fsig, starts_ptr, _output_ptr)
            //     }
            // }

            function boundsFromStarts(index, _starts_ptr) -> start, end {
                start := 0
                if gt(index, 0) {
                    start := mslice(add(_starts_ptr, mul(sub(index, 1), 4)), 4)
                }
                end := mslice(add(_starts_ptr, mul(index, 4)), 4)
            }

            // Only gets the small abstract type sig
            function getSig(_ptr) -> _dtsig {
                _dtsig := mslice(_ptr, 1)
            }

            function getTypeSignature(_ptr) -> _dtsig {
                _dtsig := mslice(_ptr, 4)
            }

            function getSize(_ptr) -> _size {
                _size := mslice(add(_ptr, 1), 3)
            }

            function addToSize(_ptr, addition) {
                let size := add(getSize(_ptr), addition)
                mstoremiddle(_ptr, 1, size, 3)
            }

            function getlastStartsIndex(_starts_ptr) -> _index {
                _index := add(_starts_ptr, mul(getSize(_starts_ptr), 4))
            }

            function getStartsLength(_starts_ptr) -> _length {
                let size := getSize(_starts_ptr)
                _length := add(mul(size, 4), 4)
            }

            function getlengthFromStarts(_starts_ptr) -> _length {
                _length := mslice(getlastStartsIndex(_starts_ptr), 4)
            }

            function getValuesPointer(_starts_ptr) -> _index {
                let dtsig := mslice(_starts_ptr, 1)
                switch dtsig
                case 0xee {
                    _index := add(getlastStartsIndex(_starts_ptr), 4)
                }
                case 0x44 {
                    _index := getValuesPointer(add(_starts_ptr, 4))
                }
                default {
                    _index := add(_starts_ptr, 4)
                }
            }

            function getTypeLength(_starts_ptr) -> _length {
                let dtsig := getSig(_starts_ptr)
                switch dtsig
                case 0xee {
                    _length := getlengthFromStarts(_starts_ptr)
                }
                case 0x44 {
                    let size := getSize(_starts_ptr)
                    _length := mul(mul(_length, size), getTypeLength(add(_starts_ptr, 4)))
                }
                default {
                    _length := getSize(_starts_ptr)
                }
            }

            function storeType(_pointer, mapKey) {
                storeData(_pointer, mappingTypeKey(mapKey))
            }

            function storeInput(_pointer, mapKey) {
                storeData(_pointer, mappingProgInputKey(mapKey))
            }

            function storeProgSteps(_pointer, mapKey) {
                storeData(_pointer, mappingProgStepsKey(mapKey))
            }

            function getType(_pointer, mapKey) {
                getStoredData(_pointer, mappingTypeKey(mapKey))
            }

            function getInput(_pointer, mapKey) {
                getStoredData(_pointer, mappingProgInputKey(mapKey))
            }

            function getProgSteps(_pointer, mapKey) {
                getStoredData(_pointer, mappingProgStepsKey(mapKey))
            }

            // does not contain the steps size
            function getProgStepPointer(_pointer, index) -> _new_ptr {
                _new_ptr := _pointer
                for { let i := 0 } lt(i, index) { i := add(i, 1) } {
                    let input_indexes_length := mslice(add(_new_ptr, 4), 4)
                    _new_ptr := add(add(_new_ptr, 8), mul(input_indexes_length, 1))
                }
            }

            function storeData(_pointer, storageKey) {
                let slot := 32
                let sizeBytes := add(mslice(_pointer, 4), 4)
                let size := div(sizeBytes, slot)

                for { let i := 0 } lt(i, size)  { i := add(i, 1) } {
                    sstore(add(storageKey, i), mload(add(_pointer, mul(i, slot))))
                }

                let current_length :=  mul(size, slot)
                let remaining := sub(sizeBytes, current_length)
                if gt(remaining, 0) {
                    sslicestore(add(storageKey, size), mslice(add(_pointer, current_length), remaining), remaining)
                }
            }

            function getStoredData(_pointer, storageKey) {
                let slot := 32

                // read first storage slot, for the length
                mstore(_pointer, sload(storageKey))

                let sizeBytes := mslice(_pointer, 4)
                let loadedData := sub(slot, 4)
                if gt(sizeBytes, loadedData) {
                    sizeBytes := sub(sizeBytes, loadedData)
                    let size := div(sizeBytes, slot)
                    _pointer :=  add(_pointer, slot)

                    for { let i := 0 } lt(i, size)  { i := add(i, 1) } {
                        mstore(add(_pointer, mul(i, slot)), sload(add(storageKey, add(i, 1))))
                    }

                    let current_length :=  mul(size, slot)
                    let remaining := sub(sizeBytes, current_length)
                    if gt(remaining, 0) {
                        mstore(add(_pointer, current_length), sload(add(storageKey, add(size, 1))))
                    }
                }
            }

            function mappingTypeKey(key) -> storageKey {
                storageKey := mappingStorageKey(0, key)
            }

            function mappingProgInputKey(key) -> storageKey {
                storageKey := mappingStorageKey(1, key)
            }

            function mappingProgStepsKey(key) -> storageKey {
                storageKey := mappingStorageKey(2, key)
            }

             // mapping(bytes32(max) => *)
            function mappingStorageKey(storageIndex, key) -> storageKey {
                mstore(0, key, storageIndex)
                storageKey := keccak256(0, 64)
            }

            // // mapping(bytes32(max) => mapping(bytes32(max) => *)
            // function mappingStorageKey2(storageIndex, key1, key2) -> storageKey {
            //     mstore(0, key1, storageIndex, key2)
            //     mstore(96, keccak256(0, 64))
            //     storageKey := keccak256(64, 64)
            // }
        }
    }
}
