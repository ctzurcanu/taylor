object "ComplexStore" {
    code {
        datacopy(0, dataoffset("Runtime"), datasize("Runtime"))
        return(0, datasize("Runtime"))
    }
    object "Runtime" {
        code {
            dtmstruct ProgStep(
                typeid: dt.byte4,
                inputIndexes: dt.u8array
                // outputHasSlotSize: dt.boolarray
            )
            dtmstruct ProgInput(
                // count: dt.u8,
                // isize: dt.u32,
                // inputHasSlotSize: dt.boolarray,
                starts: dt.u32array,
                // outputIndexes: dt.u8array,
                input: dt.byte1array
            )
            dtmstruct Type(
                sig_bytecode: dt.dTypeSignature,
                // sig_in: dt.dTypeSignature,
                // sig_out: dt.dTypeSignature,   // for named types = byte4(hash(sign_in, name))
                size: dt.u32,
                // name: dt.byte4  // char: byte1 ? u8 ascii ? bit8 ?
                steps: dt.u8
            )

            // mapping(sig_b -> Type) dtypes
            // mapping(sig_b -> uint8 -> ProgStep) progsteps
            // maping(sig_b -> ProgInput) proginputs


            // mapping(sig_in -> [sig_b])) in
            // mapping(sig_out -> [sig_b]) out
            // mapping(sig_b -> Type)
            // mapping(name: string -> size: u32 -> sig_b)

            // this ptr gets overwritten after each internal function call
            let _internal_output_ptr := 128
            let _calldata := 256
            let _calldata2 := add(_calldata, 4)
            let _inidata := add(_calldata2, 4)

            // input: ProgInput(_data)
            // step length: _data + ProgInput.size(_data)
            // first step: ProgStep(_data + ProgInput.size(_data) - 4)
            // second step: first_step_pos + first_step.length

            calldatacopy(_calldata, 0, calldatasize())

            let fsig := mslice(_calldata, 4)
            let _data := _inidata

            // // External calls only pass through execute
            // if eq(eq(inisig, 0xffffffff), false) {
            //     mslicestore(0, 0xffff, 2)
            //     revert(0, 2)
            // }

            switch fsig

            // Execute function - the only one that returns
            case 0xffffffff {

                // the actual function called
                //  TODO: restrict to dtnew & dtcast
                let exec_fsig := mslice(_calldata2, 4)

                // for { } eq(again, true) { } {
                //     count := add(count, 1)

                executeInternal(exec_fsig, _data, _internal_output_ptr)

                let size := mslice(_internal_output_ptr, 4)
                return(add(_internal_output_ptr, 4), size)

            }

             // case dtsig"function store(bytes4 sig) view public returns(u32)" {
            case 0xfffffffe {
                // sstore(mappingInKey(Data.type.sig_in(_data)), Data.type.sig_bytecode(_data))
                // sstore(mappingOutKey(Data.type.sig_out(_data)), Data.type.sig_bytecode(_data))

                // input length
                let _ptr := _calldata2
                let sig_bytecode := Type.sig_bytecode(_ptr)
                let step_count := Type.steps(_ptr)

                storeType(_ptr, Type.size(_ptr), sig_bytecode)

                _ptr := add(_ptr, Type.size(_ptr))
                storeInput(_ptr, ProgInput.size(_ptr), sig_bytecode)


                _ptr := add(_ptr, ProgInput.size(_ptr))
                for { let i := 0 } lt(i, step_count) { i := add(i, 1) } {
                    let _size := ProgStep.size(_ptr)
                    storeProgStep(_ptr, _size, sig_bytecode, i)
                    _ptr := add(_ptr, _size)
                }
            }

            // read from storage
            case 0xfffffffd {
                let sig := mslice(_calldata2, 4)
                let _output_ptr := _internal_output_ptr
                let length := 0
                let _dtype_ptr := add(_output_ptr, 4)
                getType(_dtype_ptr, 32, sig)
                length := add(length, 32)


                let _input_ptr := add(_dtype_ptr, 32)
                getInput(_input_ptr, 32, sig)
                length := add(length, 32)

                // loop over steps & execute them
                let count := Type.steps(_dtype_ptr)
                let _step_ptr := add(_input_ptr, 32)
                for { let i := 0 } lt(i, count) { i := add(i, 1) } {
                    getProgStep(_step_ptr, 32, sig, i)
                    _step_ptr := add(_step_ptr, 32)
                    length := add(length, 32)
                }

                return(_dtype_ptr, length)
            }

            default {
                mslicestore(0, 0xffff, 2)
                revert(0, 2)
            }

            function executeInternal(exec_fsig, _data_ptr, _output_ptr) {
                let success := executeGraph(exec_fsig, _data_ptr, _output_ptr)

                if eq(success, false)  {
                    executeBaseFunction(exec_fsig, _data_ptr, _output_ptr)
                }
            }

            // Only 1 output per graph step is supported
            function executeGraph(sig, _prev_data_ptr, _output_ptr) -> success {
                // Get dtype data from storage
                // _data_ptr is actually empty - we can copy in mem.
                // TODO - we are limited to 32 bytes.. we need to also store the size

                //let length := 0
                success := false

                // leave space for inputs (maybe too small)
                // TODO what happens if we run multiple graphs & some data is left
                let _step_indexes_ptr := _prev_data_ptr
                let _step_inputs_ptr := add(_step_indexes_ptr, 64)
                let _starts_ptr := add(_step_inputs_ptr, 64)
                let _inputs_ptr := add(_starts_ptr, 64)

                let _dtype_ptr := add(_inputs_ptr, 96)

                getType(_dtype_ptr, 32, sig)

                if eq(eq(Type.sig_bytecode(_dtype_ptr), sig), true) {
                    let _input_ptr := add(_dtype_ptr, 32)
                    getInput(_input_ptr, 32, sig)

                    // mstore initial starts & inputs
                    ProgInput.starts.encodeTight(_input_ptr, _starts_ptr)
                    ProgInput.input.encodeTight(_input_ptr, _inputs_ptr)

                    let _last_start_ptr := add(_starts_ptr, mul(mslice(_starts_ptr, 4), 4))

                    // loop over steps & execute them
                    let count := Type.steps(_dtype_ptr)
                    let _step_ptr := add(_input_ptr, 32)
                    for { let i := 0 } lt(i, count) { i := add(i, 1) } {
                        getProgStep(_step_ptr, 32, sig, i)

                        // typeid, inputIndexes
                        let type_id := ProgStep.typeid(_step_ptr)



                        // write step selection indexes
                        ProgStep.inputIndexes.encodeTight(_step_ptr, _step_indexes_ptr)

                        // select from indexes & starts -> write at _step_inputs_ptr
                        select(_step_indexes_ptr, _starts_ptr, _inputs_ptr, _step_inputs_ptr)
                        if eq(i, 1) { return (_step_inputs_ptr, 64) }
                        // output is temporarily written at mem 0
                        executeInternal(type_id, _step_inputs_ptr, 0)


                        // we add the output to _inputs_ptr & add its size to _starts_ptr
                        let out_size := mslice(0, 4)

                        // get current input size from last start
                        let inputs_size := mslice(_last_start_ptr, 4)


                        // add output to inputs
                        // TODO: fixme for > 32 bytes
                        mslicestore(add(add(_inputs_ptr, 4), inputs_size), mslice(4, out_size), out_size)

                        // add the new start
                        _last_start_ptr := add(_last_start_ptr, 4)
                        mslicestore(_last_start_ptr, add(inputs_size, out_size), 4)


                        // change starts length & _last_start_ptr
                        let old_size := mslice(_starts_ptr, 4)
                        mstorehead(_starts_ptr, add(old_size, 1), 4)

                        _step_ptr := add(_step_ptr, 32)

                    }


                    return (_inputs_ptr, 32)
                    // write result to _output_ptr through select
                    mslicestore(_step_indexes_ptr, 1, 4)
                    mslicestore(add(_step_indexes_ptr, 4), mslice(_starts_ptr, 4), 1)

                    select(_step_indexes_ptr, _starts_ptr, _inputs_ptr, _output_ptr)

                    success := true
                }
            }

            function executeBaseFunction(sig, _data_ptr, _output_ptr) {
                switch sig

                // dtnew
                case 0x33333337 {
                    let _ptr := ProgInput.input.position(_data_ptr)

                    let type_id := mslice(_ptr, 8)
                    let size := mslice(add(_ptr, 4), 8)
                    mslicestore(_output_ptr, size, 4)
                    dtnew(type_id, size, add(_output_ptr, 4))
                }

                // select
                case 0x33333336 {
                    let _ptr := ProgInput.input.position(_data_ptr)
                    // don't include input.length
                    selectt(add(_ptr, 4), _output_ptr)
                }

                // dtadd
                case 0x33333333 {
                    let _ptr := ProgInput.input.position(_data_ptr)
                    let ans := dtadd(add(_ptr, 4))
                    mslicestore(_output_ptr, 4, 4)
                    mslicestore(add(_output_ptr, 4), ans, 4)
                }

                // dtsub
                case 0x33333334 {
                    let _ptr := ProgInput.input.position(_data_ptr)
                    let ans := dtsub(add(_ptr, 4))
                    mslicestore(_output_ptr, 4, 4)
                    mslicestore(add(_output_ptr, 4), ans, 4)
                }

                // contig
                case 0x33333335 {
                    let _ptr := ProgInput.input.position(_data_ptr)
                    contig(_ptr, _output_ptr)
                }

                // byte1
                case 0x33333338 {
                    // let _ptr := ProgInput.input.position(_data_ptr)
                    let ans := byte1()
                    mslicestore(_output_ptr, 1, 4)
                    mslicestore(add(_output_ptr, 4), ans, 1)
                }

                 default {
                    mslicestore(0, 0xfffe, 2)
                    revert(0, 2)
                }
            }

            function mslicestore(_ptr, val, length) {
                mstore(_ptr, shl(mul(sub(32, length), 8), val))
            }

            function sslicestore(storageKey, val, length) {
                sstore(storageKey, shl(mul(sub(32, length), 8), val))
            }

            // Use carefully
            function mstorehead(_ptr, value, length) {
                let temp := mload(_ptr)
                mslicestore(_ptr, value, length)
                mslicestore(add(_ptr, length), temp, safeSub(32, length))
            }

            function min(a, b) -> c {
                switch lt(a, b)
                case 1 { c := a }
                case 0 { c := b }
            }

            function max(a, b) -> c {
                switch gt(a, b)
                case 1 { c := a }
                case 0 { c := b }
            }

            function byte1() -> ans {
                ans := 0x11
            }

             function dtadd(pointer) -> ans {
                let a := mslice(pointer, 4)
                let b := mslice(add(pointer, 4), 4)
                ans := add(a, b)
            }

            function dtsub(pointer) -> ans {
                let a := mslice(pointer, 4)
                let b := mslice(add(pointer, 4), 4)
                ans := sub(a, b)
            }

            function contig(pointer, ans_ptr) {
                let a := mslice(pointer, 4)
                let b_length := mslice(add(pointer, 4), 4)
                let b_pointer := add(pointer, 8)

                for { let i := 0 } lt(i, a) { i := add(i, 1) } {
                    mstore(add(ans_ptr, mul(b_length, i)), shl(mul(sub(32, b_length), 8), mslice(b_pointer, b_length)))
                }
            }

            function dtnew(type_id, size, _ptr) {
                //  size - if types have same id

                // following is defined by a type_id's progsteps
                // dtnew -> gets dtype data -> executeInternal(dtype.steps)
                let pt := 0

                mslicestore(pt, size, 4)
                mslicestore(add(pt, 4), 1, 4)
                mslicestore(add(pt, 8), 0x00, 1)
                contig(pt, _ptr)
            }

            function cast(type_id1, value_ptr, type_id2, answ_ptr) {

            }

            function selectt(pointer, _output_ptr) {
                let select_pointer := pointer
                let select_length := mslice(select_pointer, 4)

                let starts_pointer := add(select_pointer, mul(select_length, 4))
                let starts_length := mslice(starts_pointer, 4)

                let b_pointer := add(starts_pointer, mul(starts_length, 4))

                select(select_pointer, starts_pointer, b_pointer, _output_ptr)
            }

            // TODO: rewrite this more efficient
            function select(select_ptr, starts_ptr, b_ptr, _output_ptr) {
                let select_length := mslice(select_ptr, 4)
                let select_pointer := add(select_ptr, 4)

                let starts_length := mslice(starts_ptr, 4)
                let starts_pointer := add(starts_ptr, 4)

                let content_pointer := add(_output_ptr, 4)
                let b_pointer := b_ptr
                let content_length := 0

                for { let i := 0 } lt(i, select_length) { i := add(i, 1) } {
                    let index := mslice(add(select_pointer, mul(i, 4)), 4)

                    let end := mslice(add(starts_pointer, mul(index, 4)), 4)
                    let start := mslice(add(starts_pointer, mul(sub(max(index, 1), 1), 4)), 4)
                    let length := sub(end, start)

                    let slice := mslice(add(b_pointer, start), length)
                    mslicestore(content_pointer, slice, length)
                    content_pointer := add(content_pointer, length)
                    content_length := add(content_length, length)
                }
                mstorehead(_output_ptr, content_length, 4)

            }

            function dtif(condition, type_id1, type_id2, arg_ptr, res_ptr) {
                switch condition
                case 0x01 {
                    dtapply(type_id1, arg_ptr, res_ptr)
                }
                case 0x02 {
                    dtapply(type_id2, arg_ptr, res_ptr)
                }
            }

            function dtapply(type_id, arg_ptr, res_ptr) {
                // fsig := type_id
            }


                // case 0x22222222 {
                //     mstore(_data, shl(mul(sub(32, 4), 8), 0x00000011))  // sig_bytecode
                //     mstore(add(_data, 4), shl(mul(sub(32, 4), 8), 0x00000022))  // sig_in
                //     mstore(add(_data, 8), shl(mul(sub(32, 4), 8), 0x00000033))  // sig_out
                //     mstore(add(_data, 12), shl(mul(sub(32, 4), 8), 0x00000008))  // ssize

                //     mstore(add(_data, 16), shl(mul(sub(32, 4), 8), 0x00000002)) // steps length

                //     mstore(add(_data, 20), shl(mul(sub(32, 4), 8), 0xcccccccc)) // typeid
                //     mstore(add(_data, 24), shl(mul(sub(32, 5), 8), 0x0000000105)) // inputIndexes
                //     mstore(add(_data, 29), shl(mul(sub(32, 5), 8), 0x0000000101)) // outputHasSlotSize

                //     mstore(add(_data, 34), shl(mul(sub(32, 4), 8), 0xdddddddd)) // typeid
                //     mstore(add(_data, 38), shl(mul(sub(32, 5), 8), 0x0000000106)) // inputIndexes
                //     mstore(add(_data, 43), shl(mul(sub(32, 5), 8), 0x0000000100)) // outputHasSlotSize

                //     fsig := 0x2edc3142
                // }

                // case dtsig"function getSigBByIn(byte4 sig) view public returns(u32)" {
                //     let key := mappingInKey(Data.type.sig_in(_data))
                //     mstore(0, sload(key))
                //     return (0, 32)
                // }

                // case dtsig"function getSigBByOut(byte4 sig) view public returns(u32)" {
                //     let key := mappingOutKey(Data.type.sig_out(_data))
                //     mstore(0, sload(key))
                //     return (0, 32)
                // }


            function storeType(_pointer, sizeBytes, mapKey) {
                storeData(_pointer, sizeBytes, mappingTypeKey(mapKey))
            }

            function storeInput(_pointer, sizeBytes, mapKey) {
                storeData(_pointer, sizeBytes, mappingProgInputKey(mapKey))
            }

            function storeProgStep(_pointer, sizeBytes, key1, key2) {
                storeData(_pointer, sizeBytes, mappingProgStepKey(key1, key2))
            }

            function getType(_pointer, sizeBytes, mapKey) {
                getStoredData(_pointer, sizeBytes, mappingTypeKey(mapKey))
            }

            function getInput(_pointer, sizeBytes, mapKey) {
                getStoredData(_pointer, sizeBytes, mappingProgInputKey(mapKey))
            }

            function getProgStep(_pointer, sizeBytes, key1, key2) {
                getStoredData(_pointer, sizeBytes, mappingProgStepKey(key1, key2))
            }

            function storeData(_pointer, sizeBytes, storageKey) {
                let size := safeAdd(safeDiv(sizeBytes, 32), 1)
                let currentStorageKey := storageKey
                let currentPointer := _pointer
                for { let i := 0 } lt(i, size)  { i := safeAdd(i, 1) } {
                    let chunk := 32
                    let remaining := sub(sizeBytes, mul(i, 32))
                    if lt(remaining, chunk) { chunk := remaining }
                    currentStorageKey := safeAdd(currentStorageKey, i)
                    // sstore(currentStorageKey, mslice(currentPointer, chunk))
                    sslicestore(currentStorageKey, mslice(currentPointer, chunk), chunk)
                    currentPointer := safeAdd(currentPointer, 32)
                }
            }

            function getStoredData(_pointer, sizeBytes, storageKey) {
                let size := safeDiv(sizeBytes, 32)
                if lt(mul(size, 32), sizeBytes) {
                    size := add(size, 1)
                }
                let currentStorageKey := storageKey
                let currentPointer := _pointer
                for { let i := 0 } lt(i, size)  { i := safeAdd(i, 1) } {
                    let chunk := 32
                    let remaining := sub(sizeBytes, mul(i, 32))
                    if lt(remaining, chunk) { chunk := remaining }
                    currentStorageKey := safeAdd(currentStorageKey, i)
                    mslicestore(_pointer, sload(currentStorageKey), chunk)
                    currentPointer := safeAdd(currentPointer, 32)
                }
            }

            // function mappingInKey(key) -> storageKey {
            //     storageKey := mappingStorageKey(0, key)
            // }

            // function mappingOutKey(key) -> storageKey {
            //     storageKey := mappingStorageKey(1, key)
            // }

            function mappingTypeKey(key) -> storageKey {
                storageKey := mappingStorageKey(0, key)
            }

            function mappingProgInputKey(key) -> storageKey {
                storageKey := mappingStorageKey(1, key)
            }

            function mappingProgStepKey(sig_b, step_count) -> storageKey {
                storageKey := mappingStorageKey2(2, sig_b, step_count)
            }

            // function mappingNamedKey(key1, key2) -> storageKey {
            //     storageKey := mappingStorageKey2(3, key1, key2)
            // }

             // mapping(bytes32(max) => *)
            function mappingStorageKey(storageIndex, key) -> storageKey {
                mstore(0, key, storageIndex)
                storageKey := keccak256(0, 64)
            }

            // mapping(bytes32(max) => mapping(bytes32(max) => *)
            function mappingStorageKey2(storageIndex, key1, key2) -> storageKey {
                mstore(0, key1, storageIndex, key2)
                mstore(96, keccak256(0, 64))
                storageKey := keccak256(64, 64)
            }
        }
    }
}
